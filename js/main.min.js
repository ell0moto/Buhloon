'use strict';

/* ==========================================================================
   BOOTSTRAPPER
   ========================================================================== */

//app is an module that is dependent on several top level modules
var app = angular.module('App', [
	'Controllers',
	'Filters',
	'Services',
	'Directives',
	'ngResource', //for RESTful resources
	'ngCookies',
	'ui', //from Angular UI
	'ui.bootstrap'
]);

//Define all the page level controllers (Application Logic)
angular.module('Controllers', []);
//Define all shared services (Interaction with Backend)
angular.module('Services', []);
//Define all shared directives (UI Logic)
angular.module('Directives', []);
//Define all shared filters (UI Filtering)
angular.module('Filters', []);



/* ==========================================================================
   ROUTER
   ========================================================================== */

//Define all routes here and which page level controller should handle them
app.config(
	[
		'$routeProvider',
		'$locationProvider',
		function($routeProvider, $locationProvider) {
			
			//HTML5 Mode URLs
			$locationProvider.html5Mode(true).hashPrefix('!');
			
			//Routing
			$routeProvider
				.when(
					'/',
					{
						templateUrl: 'home_index.html',
						controller: 'HomeIndexCtrl',
					}
				)
				.when(
					'/main',
					{
						templateUrl: 'main_index.html',
						controller: 'MainIndexCtrl',
					}
				)
				.otherwise(
					{
						redirectTo: '/'
					}
				);
			
		}
	]
);

/* ==========================================================================
   CONFIGURE ANGULAR UI
   ========================================================================== */
/*
app.value('ui.config', {
	select2: {
		allowClear: true
	}
});
*/

/* ==========================================================================
   GLOBAL FEATURES
   ========================================================================== */

app.run([
	'$rootScope',
	'$cookies',
	'$http',
	function($rootScope, $cookies, $http){
	
		//XSRF INTEGRATION
		
		$rootScope.$watch(
			function(){
				return $cookies[serverVars.csrfCookieName];
			},
			function(){
				$http.defaults.headers.common['X-XSRF-TOKEN'] = $cookies[serverVars.csrfCookieName];
			}
		);
		
		
		//XHR ERROR HANDLER
		
	}
]);

'use strict';

angular.module('Controllers')

	.controller('LogInOutSubCtrl', [
		'$scope',
		'$location',
		'UsersServ',
		function($scope, $location, UsersServ) {

			$scope.login = function() { //function expression

				var payload = {
					username: $scope.username,
					password: $scope.password,
				};

				//reset the submission errors!
				$scope.loginErrors = [];
				$scope.validationErrors = {};

				UsersServ.loginSession( //passing in arguments
					payload,

					function(successResponse) { //anonomous function call back

						console.log('Successfully Logged In');
						UsersServ.setUserData('id', successResponse.content);
						$location.path('/main');
					},

					function(failResponse) {

						console.log('Could not log in');
						
						//check if it is a validation error
						if(failResponse.data.code === 'validation_error'){
							
							if(Array.isArray(failResponse.data.content)){
							
								//if it is an array
								$scope.loginErrors = failResponse.data.content;
							
							}else{
							
								//else it's an object
								$scope.validationErrors = {
									username: failResponse.data.content.username,
									password: failResponse.data.content.password,
									rememberMe: failResponse.data.content.rememberMe
								};
							}
						}
					}
				);

			};

			$scope.logout = function(){

				UsersServ.logoutSession(UsersServ.getUserData().id);
				//$scope.$emit('authenticationDestroy', Us);
			};

			$scope.$on('authenticationProvided', function(event,args) { //authenticationProvided is a global event that is being listen to
				$scope.state = true; //anything attached to $scope.state is a model
			});

			$scope.$on('authenticationLogout', function(event,args) {
				$scope.state = false;
			});

		}
	])

	.controller('RewardsSubCtrl', [
		'$scope',
		'IncentivesServ',
		function($scope, IncentivesServ){

			//get
			$scope.get = function() {

				//get all rewards according to User ID
				IncentivesServ.get( 
					{
						// id:'9',
					},
					function(response){
						$scope.rewards = response.content; //references object .content and passes in it's array.
						console.log(response, '<- QUERY');
					},
					function(response){
						console.log('Error! Well this is hawkard'); //this comes from the fail function
					}
				);

			};

			//Post (create)
			$scope.submit = function() {

				var payload = {
					titleOfReward: $scope.titleOfReward,
					ribbonCost: $scope.ribbonCost,
				};

				IncentivesServ.save( 
					{}, //parameter passes in through URL
					payload,
					function(response){
						console.log(response, '<- SAVE');
					}
				);
			};

			//Delete
			$scope.remove = function(id) { 

				console.log(id);

				IncentivesServ.remove(
					{
						id: id,
					},
					function(response){
						console.log(response, '<- REMOVE');
					}
				);
			};

		}
	])

	.controller('ActivitySubCtrl', [
		'$scope',
		'NotificationsServ',
		function($scope, NotificationsServ){

			$scope.isCollapsed = true;

//Get all notices & obligations (according to specific id)
			$scope.get = function() {
			
				NotificationsServ.get( 
					{},
					function(response){

						$scope.noticesData = response.content; //references object .content and passes in it's array.
						console.log(response, '<- QUERY');
					},
					function(response){
						console.log('Error! Well this is hawkard'); //this comes from the failure function
					}
				);
			};

//Post (create) obligation
			$scope.submit = function() { //function expression

				// var payload = { //payload is an object, created via literal notation
				// 	titleOfPlan: $scope.titleOfPlan,
				// 	description: $scope.description,
				// 	nameOfChild: $scope.nameOfChild,
				// 	totalIteration: $scope.totalIteration,
				// 	specificReward: $scope.specificReward,
				// 	noRibbon: $scope.noRibbon,
				// 	progress: 0,
				// 	active: 0,
				// 	complete: 0,
				// };

				// NotificationsServ.save( //.save is a function being called
				// 	{}, //1st parameter passes in through URL
				// 	payload,
				// 	function(response){
				// 		console.log(response, '<- SAVE');
				// 	}
				// );
			};
			
			
// Put (update) obligation
			$scope.addItem = function(item) {

				// var values;
				// for (values in item) {
				// 	if (values === "progress") {
				// 		item[values] = (item[values] + 1);
				// 	}
				// 	if (values === "active") {
				// 		item[values] = 1;
				// 	}

				// };

				// if (item["progress"] === item["totalIteration"]) {
				// 	item["complete"] = 1;
				// };

				// console.log(item);

				// NotificationsServ.update(
				// 	{id:0,}, //Dummy data to satisfy RESTFUL
				// 	item,
				// 	function(response){
				// 		console.log(response, '<- UPDATE');
				// 	}
				// );

			};

//Soft delete notices & obligations
			$scope.remove = function(item) {

				item.active = 0;

				console.log(item);

				NotificationsServ.remove(
					{id:0,}, //Dummy data to satisfy RESTFUL
					item,
					function(response){
						console.log(response, '<- SOFT DELETE');
					}
				);
			};
	
		}
	]);
'use strict';

//Page Level Controller
//Can have multiple mini controllers, similar to methods
angular.module('Controllers')
	.controller('HomeIndexCtrl', [
		'$scope',
		function($scope){
			$scope.data = 'HELLO!';
		}
	]);
'use strict';

angular.module('Controllers')
	.controller('MainIndexCtrl', [
		'$scope',
		'OffspringServ',
		'OperationsServ',
		'IncentivesServ',
		function($scope, OffspringServ, OperationsServ, IncentivesServ){

			//Get all children (according to specific id)
			OffspringServ.get( 
				{},
				function(response){

					$scope.children = response.content; //references object .content and passes in it's array.
					console.log($scope.children, '<- QUERY');
				},
				function(response){
					console.log('Error! No children'); //this comes from the failure function
				}
			);

			//Get all rewards (according to specific id)
			IncentivesServ.get(
				{
					// id:'9',
				},
				function(response){
					$scope.rewards = response.content; //references object .content and passes in it's array.
					console.log(response, '<- QUERY');
				},
				function(response){
					console.log('Error! Well this is hawkard'); //this comes from the fail function
				}
			);  	


			//Post (create) plan
			$scope.submit = function() { //function expression

				var payload = { //payload is an object, created via literal notation
					titleOfPlan: $scope.titleOfPlan,
					description: $scope.description,
					nameOfChild: $scope.nameOfChild,
					totalIteration: $scope.totalIteration,
					specificReward: $scope.specificReward,
					noRibbon: $scope.noRibbon,
					progress: 0,
					active: 0,
					complete: 0,
				};

				OperationsServ.save( //.save is a function being called
					{}, //1st parameter passes in through URL
					payload,
					function(response){
						console.log(response, '<- SAVE'); //upon success add payload to plansData
					}
				);

			};
		}
	])


	.controller('ChildrenSubCtrl', [
		'$scope',
		'OperationsServ',
		function($scope, OperationsServ){

			$scope.isCollapsed = true;

			//Get all plans (according to child id)
			OperationsServ.get( 
				{
					id:$scope.child.id,
				},
				function(response){

					$scope.plans = response.content; //references object .content and passes in it's array.
					console.log(response, '<- QUERY');
				},
				function(response){
					console.log('Error! No plans'); //this comes from the failure function
				}
			);

		}
	])

	.controller('PlansSubCtrl', [
		'$scope',
		'OperationsServ',
		function($scope, OperationsServ){

			$scope.plan.percent = (($scope.plan.progress)/($scope.plan.totalIteration)*100 + "%");
			$scope.plan.colour = ('#' + (Math.random() * 0xFFFFFF << 0).toString(16));

			// Put (update) plan
			$scope.addItem = function(item) {

				item.progress = (item.progress + 1);
				item.active = 1;
				if (item.progress === item.totalIteration) {
					item.complete = 1;
				}

				OperationsServ.update(
					{id:0,}, //Dummy data to satisfy RESTFUL
					item,
					function(response){
						console.log(response, '<- UPDATE');
					}
				);

			};


			//Delete plan
			$scope.remove = function(id) {

				OperationsServ.remove(
					{
						id:id,
					},
					function(response){
						console.log(response, '<- REMOVE');
					}
				);
			};

		}
	]);






			
			
// // Put (update) plan
// 			$scope.addItem = function(item) {

// 				item.progress = (item.progress + 1);
// 				item.active = 1;
// 				if (item.progress === item.totalIteration) {
// 					item.complete = 1;
// 				};

// 				console.log(item);

// 				OperationsServ.update(
// 					{id:0,}, //Dummy data to satisfy RESTFUL
// 					item,
// 					function(response){
// 						console.log(response, '<- UPDATE');
// 					}
// 				);

// 			};


'use strict';

angular.module('Directives')
	.directive('modalBoxDir', [
		'$parse', 
		'$dialog', 
		function($parse, $dialog) {
	  		return {
		    restrict: 'EA',
		    terminal: true,
			    link: function(scope, elm, attrs) {
			      var opts = angular.extend({}, scope.$eval(attrs.uiOptions || attrs.bsOptions || attrs.options));
			      var shownExpr = attrs.modal || attrs.show;
			      var setClosed;

			      // Create a dialog with the template as the contents of the directive
			      // Add the current scope as the resolve in order to make the directive scope as a dialog controller scope
			      opts = angular.extend(opts, {
			        template: elm.html(),
			        resolve: { $scope: function() { return scope; } }
			      });
			      var dialog = $dialog.dialog(opts);

			      elm.remove();

			      if (attrs.close) {
			        setClosed = function() {
			          $parse(attrs.close)(scope);
			        };
			      } else {
			        setClosed = function() {
			          if (angular.isFunction($parse(shownExpr).assign)) {
			            $parse(shownExpr).assign(scope, false);
			          }
			        };
			      }

			      scope.$watch(shownExpr, function(isShown, oldShown) {
			        if (isShown) {
			          dialog.open().then(function(){
			            setClosed();
			          });
			        } else {
			          //Make sure it is not opened
			          if (dialog.isOpen()){
			            dialog.close();
			          }
			        }
			      });
			    }
		  	};
		}
	]);
'use strict';

angular.module('Directives')
	.directive('placeHolderDir', [
		function(){
			
			return {
			    restrict: 'A',
			    require: 'ngModel',
			    link: function(scope, element, attr, ctrl) {      
			      
			      var value;
			      
			      var placeHolderDir = function () {
			          element.val(attr.placeHolderDir)
			      };
			      var unPlaceHolderDir = function () {
			          element.val('');
			      };
			      
			      scope.$watch(attr.ngModel, function (val) {
			        value = val || '';
			      });

			      element.bind('focus', function () {
			         if(value == '') unPlaceHolderDir();
			      });
			      
			      element.bind('blur', function () {
			         if (element.val() == '') placeHolderDir();
			      });
			      
			      ctrl.$formatters.unshift(function (val) {
			        if (!val) {
			          placeHolderDir();
			          value = '';
			          return attr.placeHolderDir;
			        }
			        return val;
			      });
			    }
		  };
		}
	]);
'use strict';

angular.module('Services')
	.factory('AccountsServ', [
		'$resource',
		function($resource){
		
			return $resource(
				'api/accounts/:id',
				{},
				{
					update: {
						method: 'PUT'
					}
				}
			);
		
		}
	]);
'use strict';

//Response Handler for Error Codes across all HTTP requests to show an alert box!

angular.module('Services')
	.config([ // Config phase to acquuire the $httpProvider service
		'$provide', // The provide service is only available in the configuration block, it allows the creation of services, factories, providers, values, constants and decorators
		'$httpProvider', // You can only inject Providers in config blocks
		function($provide, $httpProvider){

			//model variable...
			var httpMessages = [];

			//bind the httpMessages array to the httpMessages key so it can be dependency injected
			//the $provide configures the dependency injector, this is because we don't actually want to dependency inject this ErrorResponse handler, but instead it's output
			$provide.value('httpMessages', httpMessages);

			//we are using the responseInterceptors function to push in interceptors, as there could be multiple interceptors
            //$q is a promise implementation allowing us to pass a promise of a future value even if it doesn't exist currently
            $httpProvider.responseInterceptors.push(['$q', function($q) {

            		//we are in the interceptor that is being added to the list of responseInterceptors
 
                	//we have to return a function that accepts a promise parameter, and return the original or new promise

                	return function(promise) {

                		//here we are using a promise and applying a then function
                		return promise.then( //'then' is part of the promise API
                			function(sucessResponse) {

                				//we only want to show anything that wasn't a GET based request
                            	//these allow you show messages, you don't have to show these types though (because usually not required)

                            	//here I'm intercepting the HTTP method for the success, because the same 200 code could be used for multiple success states
	                            switch(successResponse.config.method.toUpperCase()) {
	                            	case 'GET':
	                            		httpMessages.push({
	                            			message: 'Successfully Received',
	                            			type: 'success'
	                            		});
	                            		break;
                            		case 'POST':
                                    	httpMessages.push({
                                        	message: 'Successfully Posted',
                                        	type: 'success'
                                    	});
                                    	break;
                                	case 'PUT':
                                    	httpMessages.push({
	                                        message: 'Successfully Updated',
	                                        type: 'success'
                                    	});
                                    break;
                                	case 'DELETE':
                                    	httpMessages.push({
	                                        message: 'Sucessfully Deleted',
	                                        type: 'success'
                                    	});
                                    break;
	                            }
	                            return successResponse;
                			},
                			function(failureResponse) {

                				//here I'm intercepting the actual HTTP status
                				//PUT CODE HERE
                			}
                		);
                	};
            }]);
		}]);
'use strict';

angular.module('Services') //.factory is a more configurable but .provider is most configurable, you cannot have [] 'di' injection because it's in to the config phase not run phase

	.factory('IncentivesServ', [ //declared service for a resource, which is then injected into a controller

		'$resource', //[]dependency injected Angual JS module '$resource' required
		function($resource){
			
			return $resource('api/incentives/:id', //id comes in a paramater
				{},//default paramenters for the resource object, left empty a this stage
				{
					update:{ //custom method
						method: 'PUT', //THIS METHOD DOESN'T EXIST BY DEFAULT
					}
				}
			);
			
		}
	])

	.factory('OperationsServ', [ 

		'$resource', 
		function($resource){
			
			return $resource('api/operations/:id',
				{},
				{
					update:{ 
						method: 'PUT', 
					}
				}
			);
		}
	])

	.factory('NotificationsServ', [ 

		'$resource', 
		function($resource){
			
			return $resource('api/notifications/:id',
				{},
				{
					update:{ 
						method: 'PUT', 
					}
				}
			);
		}
	])

	.factory('OffspringServ', [ 

		'$resource', 
		function($resource){
			
			return $resource('api/offspring/:id',
				{},
				{
					update:{ 
						method: 'PUT', 
					}
				}
			);
		}
	]);
'use strict';

angular.module('Services') //.factory is a more configurable but .provider is most configurable, you cannot have [] 'di' injection because it's in to the config phase not run phase

	.factory('SessionsServ', [ //declared service for a resource, which is then injected into a controller

		'$resource', //[]dependency injected Angual JS module '$resource' required
		function($resource){
			
			return $resource('api/sessions/:id', //id comes in a paramater
				{},//default paramenters for the resource object, left empty a this stage
				{
					update:{ //custom method
						method: 'PUT', //THIS METHOD DOESN'T EXIST BY DEFAULT
					}
				}
			);
			
		}
	]);
'use strict';

/**
 * This service will abstract the creation, session management, and authencation of the current user.
 * If you need to manage users in general, don't use this, and use the AccountsServ directly!
 * There are three possibilities of needing authenticaion:
 *  1. Visits page that completely needs authentication
 *  2. Visits page that partially requests authentication
 *  3. Directly visits authentication login page
 * Six events will be broadcasted/listened to
 *  1. authenticationPartial - Authentication Triggered on an XHR request due to 401 or 403 status code 
 *  2. authenticationLogin - User has successfully logged in
 *  3. authenticationProvided - We have all the user information (propagate changes)
 *  4. authenticationDestroy - Authentication needs to logout (due to account deletion, or when person hits logout button)
 *  5. authenticationLogout - User has successfully logged out (propagate changes)
 *  6. authenticationRegister - User has successfully registered
 *  7. authenticationFull - Authentication is needed for the entire page state
 * You should listen for authenticationPartial in order to trigger a modal box dropdown for login
 * You should listen for authenticationProvided in order to restart any authenticated actions
 * You should trigger authenticationFull in any page controller that needs to check if the person is logged in and to handle it if they are not
 * You should trigger authenticationDestroy whenever someone clicks on a logout button
 * At startup we check if the session exists, if it does, we need the id of the current user, and grab its account data on startup, or else we'll have to login each time.
 */
angular.module('Services')
	.config([
		'$httpProvider',
		function($httpProvider){
			
			$httpProvider.responseInterceptors.push(['$q', '$rootScope', function($q, $rootScope){
			
				return function(promise){
				
					return promise.then(
						function(successResponse){
							return successResponse;
						},
						function(failResponse){
						
							//401 means login required (usually HTTP authentication, but we'll fudge it)
							//403 means that the person does not have enough permissions, regardless of login
							if(failResponse.status === 401 || failResponse.status === 403){
							
								var deferred = $q.defer();
								
								var req = {
									config: failResponse.config,
									deferred: deferred
								};
								
								//this event handler will append the requests
								$rootScope.$broadcast('authenticationPartial', req);
								
								//when the promise gets resolved, the rest of the callback code will activate
								return deferred.promise;
							
							}
							
							//otherwise return the fail response
							return $q.reject(failResponse);
							
						}
					);
				
				};
			
			}]);
		
		}
	])
	.provider('UsersServ', function(){
		
		var userData = {}, //userData is an object containing all the userData
			redirectDestination = '', //for saved redirect destination (by default it's home)
			loginPage = '/auth', //this will be configurable, but by default it's /login
			authenticationPartial = false, //this will be set as true when it's a partial authentication
			authenticatedRequests = []; //saved list of 401 and 403 requests that need authentication to be retried
		
		//allowing loginPage to be configurable
		this.setLoginPage = function(newLoginPage){
			loginPage = newLoginPage;
		};
		
		//the injectable instance
		this.$get = [
			'$rootScope',
			'$location',
			'$http',
			'AccountsServ',
			'SessionsServ',
			function($rootScope, $location, $http, AccountsServ, SessionsServ){
		
				//handling account creation API
				var userAPI = {
				
					getUserData: function(){
						return userData;
					},
					
					setUserData: function(newUserData){
						angular.extend(userData, newUserData); //only 1 dimensional!
					},
					
					//no promises available on $resources, so we just have to add a callback chaining
					registerAccount: function(payload, successFn, failFn){
					
						AccountsServ.save(
							{},
							payload,
							function(successResponse){
							
								//broadcast this event, should result in login attempt
								$rootScope.$broadcast('authenticationRegister', payload);
								
								if(typeof successFn === 'function'){
									successFn(successResponse);
								}
								
							},
							function(failResponse){
							
								if(typeof failFn === 'function'){
									failFn(failResponse);
								}
								
							}
						);
					
					},
					
					deleteAccount: function(id, successFn, failFn){
					
						AccountsServ.remove(
							{
								id: id
							},
							function(successResponse){
							
								//if this person's account got deleted
								//will lead to logout
								$rootScope.$broadcast('authenticationDestroy', id);
								
								if(typeof successFn === 'function'){
									successFn(successResponse);
								}
								
							},
							function(failResponse){
							
								if(typeof failFn === 'function'){
									failFn(failResponse);
								}
								
							}
						);
						
					},
					
					//only works if the person is logged in! (this needs to be ran on startup)
					getAccount: function(id, successFn, failFn){
					
						AccountsServ.get(
							{
								id: id
							},
							function(successResponse){
							
								//store the data on userData
								userData = successResponse.content;
								
								$rootScope.$broadcast('authenticationProvided', userData);
							
								if(typeof successFn === 'function'){
									successFn(successResponse);
								}
								
							},
							function(failResponse){
							
								if(typeof failFn === 'function'){
									failFn(failResponse);
								}
								
							}
						);
					
					},
					
					loginSession: function(payload, successFn, failFn){
					
						SessionsServ.save(
							{},
							payload,
							function(successResponse){
							
								//broadcast successful login (now go grab data for the listeners)
								$rootScope.$broadcast('authenticationLogin', successResponse.content);
								
								if(typeof successFn === 'function'){
									successFn(successResponse);
								}
								
							},
							function(failResponse){
							
								if(typeof failFn === 'function'){
									failFn(failResponse);
								}
								
							}
						);
					
					},
					
					logoutSession: function(id, successFn, failFn){
					
						SessionsServ.remove(
							{
								id: id
							},
							function(successResponse){
							
								$rootScope.$broadcast('authenticationLogout', successResponse.content);
								
								//reset the userData
								userData = {};
								
								if(typeof successFn === 'function'){
									successFn(successResponse);
								}
								
							},
							function(failResponse){
							
								if(typeof failFn === 'function'){
									failFn(failResponse);
								}
								
							}
						);
					
					},
					
					//this acquires session information based on the session id
					getSession: function(id, successFn, failFn){
					
						SessionsServ.get(
							{
								id: id
							},
							function(successResponse){
							
								//if successResponse has an userId, this means is already logged in, so we should go get the account
								if(typeof successResponse.content.userId !=== 'undefined'){
									$rootScope.$broadcast('authenticationLogin', successResponse.content.userId);
								}
							
								if(typeof successFn === 'function'){
									successFn(successResponse);
								}
								
							},
							function(failResponse){
							
								if(typeof failFn === 'function'){
									failFn(failResponse);
								}
								
							}
						);
					
					}
				
				};
				
				//PARTIAL AUTHENTICATION DUE TO 401 ON HTTP INTERCEPTORS (403s are for unauthorisation regardless of login, like needing admin permissions)
				$rootScope.$on('authenticationPartial', function(event, args){
				
					//this will only work if you attempt to fill up the session data from the very beginning
					//first check if userData object is empty, meaning that person was not logged in
					if(Object.keys(userData).length === 0){
					
						//clear the redirect
						redirectDestination = '';
						//setup that it is a partial
						authenticationPartial = true;
						//push the request object into the authenticatedRequests
						authenticatedRequests.push(args);
					
					}
					
					//if it reached here, this means person is logged in, but still received either a 401/403
					//either we're not truly logged in (due to tampering)
					//or the person does not have enough permissions to view the data
					//regardless, we now have to ignore the request
					
				});
				
				//FULL AUTHENTICATION TRIGGERED FROM PAGE CONTROLLER
				//this has no group scaling, it just needs person to be logged in!
				$rootScope.$on('authenticationFull', function(event, args){				
				
					//if the userData object is empty, meaning the user has not logged in, then we do the redirect
					//otherwise nothing happens
					if(Object.keys(userData).length === 0){
				
						//remember current page
						redirectDestination = $location.path;
						//redirect to login page (configured path)
						$location.path(loginPage);
					
					}
					
				});
				
				//COMPLETED REGISTRATION (MAY OVERRIDE AUTHENTICATION FULL)
				$rootScope.$on('authenticationRegister', function(event, args){
					
					//point to home after account is created
					redirectDestination = '/';
					userAPI.loginSession({
						username: args.username,
						password: args.password
					});
				
				});
				
				//COMPLETED ACCOUNT DESTRUCTION
				$rootScope.$on('authenticationDestroy', function(event, args){
				
					//point to home after account is deleted
					redirectDestination = '/';
					userAPI.logoutSession(args);
				
				});
				
				//COMPLETED LOGIN
				$rootScope.$on('authenticationLogin', function(event, args){
					
					//get the account information based on the id
					userAPI.getAccount(args);
					
					//redirect to home
					if(redirectDestination){
						$location.path(redirectDestination); //this could be home, a particular page, or no redirection at all
						redirectDestination = '';
					}
					
					var httpRetry = function(request){
						$http(request.config).then(
							function(response){
								request.deferred.resolve(response);
							},
							function(response){
								request.deferred.reject(response);
							}
						);
					};
					
					if(authenticationPartial){
						for(var i = 0; i < authenticatedRequests.length; i++){
							httpRetry(authenticatedRequests[i]);
						}
						authenticationPartial = false; //reset it
						authenticatedRequests = []; //reset the authenticated requests buffer
					}
				
				});
				
				//COMPLETED LOGOUT
				$rootScope.$on('authenticationLogout', function(event, args){
				
					if(redirectDestination){
						$location.path(redirectDestination); //this could be home, if account was deleted, or no redirection if the person simply clicked a button to logout
						redirectDestination = '';
					}
					
				});
				
				return userAPI;
		
			}
		];
		
	})
	.run([
		'UsersServ',
		function(UsersServ){
		
			//This will run at startup in order to determine if the user is already logged in, if it is, we need to grab the userData, and broadcast authenticationProvided!
			
			//acquires the session, if there is a user id, it means we're logged in, so we should broadcast authenticationLogin
			UsersServ.getSession(0);
			//it's 0 meaning that we want the current session, not a particular person's session
			
		}
	]);